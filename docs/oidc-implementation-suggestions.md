# OIDC Implementation Suggestions

> **Disclaimer**: This document was generated by Claude Sonnet 4.5 on February 14, 2026. The author ([@baptisterajaut](https://github.com/baptisterajaut)) does not know Rust at all, so this is either AI-generated potentially sloppy research, or nothing at all. Take it as exploratory analysis, not gospel. If you're a Rust purist or an absolutly anti-AI person (which I understand and respect), feel free to submit corrections, or ignore it entirely and do everything by yourself. 
>
> **Scope**: The goal is to implement Keycloak authentication for this Helmfile-based self-hosted deployment. This implementation will **not** be submitted upstream to Stoatchat — when maintainers say they want "oauth2 but not OIDC" ([stoatchat/stoatchat#412](https://github.com/stoatchat/stoatchat/issues/412)), they mean they may provide a resource server (OAuth2 provider for third-party apps) but they won't let you use an external IdP to login. This will only ever be an unofficial fork and/or adaptation for self-hosters who need SSO.

This document summarizes research into adding OpenID Connect (OIDC) authentication to Stoatchat. It covers the current auth architecture (authifier), available Rust OIDC libraries, and four possible implementation approaches. The hybrid OIDC layer approach was chosen for its balance of pragmatism, low risk, and reasonable implementation effort.

## Current Authentication Architecture (authifier)

Stoatchat uses **[authifier](https://github.com/authifier/authifier)**, an external Rust library providing complete email/password authentication with the following features:

### Core Features
- **Session management**: Unique session per device, allowing users to view active sessions and remotely logout
- **Security**: Progressive lockout (3 failed attempts), TOTP MFA support, email normalization (Gmail dots, plus-signing)
- **Integration**: Three Rocket route modules mounted at `/auth/{account,session,mfa}`
- **Events**: Emits `AuthifierEvent` (CreateAccount, CreateSession, DeleteSession, etc.) consumed by Stoatchat services

### Integration Code
```rust
let authifier = db.clone().to_authifier().await;
rocket.mount("/auth/account", rocket_authifier::routes::account::routes())
      .mount("/auth/session", rocket_authifier::routes::session::routes())
      .mount("/auth/mfa", rocket_authifier::routes::mfa::routes())
```

All login logic resides in `authifier/crates/rocket_authifier/src/routes/session/login.rs`: password validation, normalized email lookup, session creation, MFA challenge.

---

## OIDC Options in Rust Ecosystem

### Base Libraries
- **[openidconnect](https://crates.io/crates/openidconnect)**: Mature, well-maintained library with full OIDC Core 1.0 and Discovery 1.0 support ([docs.rs](https://docs.rs/openidconnect/), [GitHub](https://github.com/ramosbugs/openidconnect-rs))
- **[oidc](https://crates.io/crates/oidc)**: Alternative with UMA2 support

### Framework Integrations
- **[rocket_oidc](https://github.com/csssuf/rocket_oidc)**: The only Rocket integration found, but **abandoned** (2018, Rocket 0.3.17 vs 0.5.1 in Stoatchat, 5 commits, unmaintained)
- **[actix_web_openidconnect](https://lib.rs/crates/actix_web_openidconnect)**: Mature middleware for actix-web with Authorization Code Flow + PKCE support

**Verdict**: No turnkey solution exists for Rocket 0.5. Any OIDC integration must be custom-built.

---

## Approaches Explored

Four approaches were evaluated (detailed analysis in [Appendix](#appendix-detailed-approach-comparison)):

1. **Extend authifier**: Fork authifier to add OIDC support → high maintenance burden, upstream divergence risk
2. **Hybrid OIDC layer**: Add OIDC overlay in delta, bridge to authifier → pragmatic, zero risk to existing auth
3. **Replace authifier**: Custom OIDC-first system → major rewrite, loses existing features
4. **Migrate to actix-web**: Switch framework for `actix_web_openidconnect` → prohibitive effort

**Chosen approach**: Hybrid OIDC layer (option 2). Balances implementation effort (~1-2 weeks), risk (no authifier changes), and maintainability.

---

## Chosen Approach: Hybrid OIDC Layer

### Implementation Overview

1. **Implement OIDC layer** in `crates/delta` using `openidconnect` for Authorization Code + PKCE flow
2. **Create `oidc.rs` module** with:
   - Route `/auth/oidc/login` → generates authorization URL, stores PKCE challenge in temporary session, redirects to IdP
   - Route `/auth/oidc/callback` → exchanges code for token, validates claims, retrieves email
3. **Bridge to authifier**:
   - Lookup authifier account by normalized email
   - If absent: create account via `Account::new()` with random password and `verification = Verified` (skip email confirmation)
   - Create authifier session via `account.create_session()`
   - Return standard session token
4. **Configuration**: Add `[api.oidc]` section in `Revolt.toml` (issuer, client_id, client_secret, redirect_uri)
5. **Client**: Add "Sign in with OIDC" button in UI

### Benefits
- Functional OIDC auth without touching authifier
- Existing features (MFA, multi-device sessions, etc.) work out-of-the-box for OIDC users
- Reversible: can remove OIDC layer without impacting the rest

### Limitations
- No native OIDC single logout (would require monitoring OIDC sessions) — **addressed by backchannel logout below**
- OIDC user has a "shadow" authifier account (transparent to them)

---

## Single Logout: Backchannel Logout Support

The **[OIDC Back-Channel Logout 1.0](https://auth0.com/docs/authenticate/login/logout/back-channel-logout)** specification solves the single logout problem.

### How It Works

When a user logs out from the IdP (or the IdP terminates their session), the IdP sends an asynchronous **POST** request to a callback URL you expose (`backchannel_logout_uri`), with a **logout token** (special JWT) in the body.

### Logout Token Structure

JWT signed by the IdP containing ([spec details](https://ldapwiki.com/wiki/Wiki.jsp?page=Logout+Token)):
```json
{
  "iss": "https://idp.example.com",
  "aud": "your-client-id",
  "iat": 1234567890,
  "jti": "unique-token-id",
  "events": {
    "http://schemas.openid.net/event/backchannel-logout": {}
  },
  "sid": "session-id-from-idp",  // and/or
  "sub": "user-id-from-idp"      // at least one required
}
```

**Validation constraints**:
- MUST contain `events` with `http://schemas.openid.net/event/backchannel-logout`
- MUST contain `sid` (session ID) and/or `sub` (user ID)
- MUST NOT contain `nonce` (prevents ID token reuse)
- JWT signature validated with IdP's JWKS

### Implementation in Stoatchat

#### 1. OIDC ↔ authifier Session Mapping

When creating an authifier session after OIDC callback, **store the link** between:
- OIDC `sid` (IdP session ID)
- authifier `session.id` (or `session.token`)

**Option A**: Add `oidc_sid` field to authifier's `Session` model (requires fork)

**Option B**: External mapping table in MongoDB:
```rust
struct OidcSessionMapping {
    oidc_sid: String,              // IdP session ID
    authifier_session_id: String,  // authifier session ID
    user_id: String,               // user ID to find all user sessions
    created_at: Timestamp,
}
```

#### 2. Backchannel Logout Callback Route

Add a Rocket route in delta:

```rust
// crates/delta/src/routes/oidc/backchannel_logout.rs

#[post("/backchannel_logout", data = "<form>")]
pub async fn backchannel_logout(
    authifier: &State<Authifier>,
    db: &State<Database>,
    config: &State<OidcConfig>,
    form: Form<BackchannelLogoutForm>,
) -> Result<Status> {
    // 1. Decode logout_token (JWT)
    let logout_token = form.logout_token;

    // 2. Validate JWT signature with IdP's JWKS
    let claims = validate_logout_token(&logout_token, config).await?;

    // 3. Verify mandatory claims
    if !claims.events.contains_key("http://schemas.openid.net/event/backchannel-logout") {
        return Err(Error::InvalidLogoutToken);
    }
    if claims.nonce.is_some() {
        return Err(Error::InvalidLogoutToken);  // security: no nonce allowed
    }

    // 4. Find corresponding authifier sessions
    let sessions = if let Some(sid) = claims.sid {
        // Lookup by OIDC session ID
        db.find_sessions_by_oidc_sid(&sid).await?
    } else if let Some(sub) = claims.sub {
        // Lookup by user ID (terminates all user's sessions)
        db.find_sessions_by_user_oidc_sub(&sub).await?
    } else {
        return Err(Error::InvalidLogoutToken);  // at least one required
    };

    // 5. Delete authifier sessions
    for session in sessions {
        authifier.database.delete_session(&session.token).await?;
        authifier.publish_event(AuthifierEvent::DeleteSession {
            user_id: session.user_id.clone(),
            session_id: session.id.clone(),
        }).await;
    }

    Ok(Status::Ok)  // 200 OK (OIDC spec requires 200)
}
```

#### 3. Logout Token Validation

Use the [`jsonwebtoken`](https://crates.io/crates/jsonwebtoken) crate:

```rust
use jsonwebtoken::{decode, decode_header, Algorithm, DecodingKey, Validation};

async fn validate_logout_token(
    token: &str,
    config: &OidcConfig,
) -> Result<LogoutTokenClaims> {
    // Fetch IdP's JWKS (caching recommended)
    let jwks = fetch_jwks(&config.jwks_uri).await?;

    // Decode header to get kid
    let header = decode_header(token)?;
    let kid = header.kid.ok_or(Error::InvalidToken)?;

    // Find corresponding public key
    let jwk = jwks.find_key(&kid).ok_or(Error::InvalidToken)?;
    let decoding_key = DecodingKey::from_jwk(jwk)?;

    // Validate token
    let mut validation = Validation::new(header.alg);
    validation.set_audience(&[&config.client_id]);
    validation.set_issuer(&[&config.issuer]);

    let token_data = decode::<LogoutTokenClaims>(token, &decoding_key, &validation)?;
    Ok(token_data.claims)
}

#[derive(Deserialize)]
struct LogoutTokenClaims {
    iss: String,
    aud: String,
    iat: u64,
    jti: String,
    events: HashMap<String, serde_json::Value>,
    sid: Option<String>,  // session ID
    sub: Option<String>,  // user ID
    nonce: Option<String>,  // MUST be absent
}
```

#### 4. IdP Configuration

When registering the OIDC client in your IdP (Keycloak, Auth0, etc.), provide:

```yaml
backchannel_logout_uri: https://stoatchat.example.com/auth/oidc/backchannel_logout
backchannel_logout_session_required: true  # requests sid in logout token
```

**Providers supporting backchannel logout**:
- Keycloak
- Auth0 (requires Enterprise plan)
- Zitadel
- authentik
- Ping Identity
- Duende IdentityServer

### Complete Workflow

#### OIDC Login
1. User clicks "Login with OIDC" → `/auth/oidc/login`
2. Redirect to IdP with `state` + PKCE challenge
3. Callback `/auth/oidc/callback` with code
4. Exchange code → access token + ID token (contains `sid` if IdP supports it)
5. Create/find authifier account, create authifier session
6. **Store mapping** `oidc_sid` → `authifier_session_id`
7. Return authifier session token to client

#### OIDC Logout (Backchannel)
1. User logs out from IdP (or admin revokes session)
2. IdP sends POST to `/auth/oidc/backchannel_logout` with logout token
3. Delta validates JWT, extracts `sid`
4. Lookup in mapping table → finds authifier sessions
5. Deletes authifier sessions
6. Emits `AuthifierEvent::DeleteSession` → pushd can notify WebSocket clients

#### Stoatchat-Initiated Logout
If a user logs out **from Stoatchat** (not the IdP), two options:
- **Do nothing**: Stoatchat session closes, but not IdP session (standard behavior)
- **RP-Initiated Logout**: Redirect to `{idp}/logout?post_logout_redirect_uri=...` to also close IdP session

### Edge Cases

#### Case 1: IdP doesn't support `sid`
If logout token contains only `sub` (user ID) and not `sid` (session ID), you must terminate **all sessions** for that user. More aggressive but spec-compliant.

#### Case 2: Network Reliability
Backchannel logout is an HTTP POST from IdP to your backend. If your backend is down, the IdP **does not retry** (best-effort). Solutions:
- Monitoring: log logout token validation failures
- Idempotence: check session exists before deleting (return 200 even if already deleted)

#### Case 3: Session Mapping Cleanup
The `oidc_sid` → `authifier_session_id` mappings must be cleaned up when:
- Backchannel logout received → delete mapping
- authifier session expired/manually deleted → cleanup mapping (cron job or trigger)

---

## Key Considerations

### 1. Email Conflicts
**Decision**: Keycloak is the source of truth. The authifier accounts are shadow accounts created by the hybrid layer.

**Deployment scenarios**:
- **Fresh deployment with Keycloak**: No conflict, all accounts created via OIDC from day one
- **Existing deployment without Keycloak**: Add OIDC, users can continue with email/password or switch to OIDC
- **Mid-production Keycloak activation**: Requires a migration script to populate Keycloak with existing authifier accounts first

**Conflict resolution**: If an OIDC login email matches an existing authifier account, link them automatically (merge). Keycloak wins in case of attribute conflicts (name, etc.).

### 2. OIDC Claims
Which attributes to retrieve beyond email?
- `name` → pre-fill display name in onboarding
- `picture` → avatar URL
- `preferred_username` → suggest username

### 3. Provider Discovery
Use OIDC Discovery for auto-configuration or manual endpoint configuration?
- Discovery URL: `{issuer}/.well-known/openid-configuration`
- Fetches: authorization_endpoint, token_endpoint, jwks_uri, etc.

### 4. Refresh Tokens
Store OIDC refresh tokens to extend sessions?
- authifier doesn't natively handle token expirations tied to IdP
- Could implement periodic token refresh in background job
- Alternatively: let sessions expire, require re-login

---

## Configuration Schema

Add to `Revolt.toml`:

```toml
[api.oidc]
enabled = true
issuer = "https://keycloak.example.com/realms/myrealm"
client_id = "stoatchat"
client_secret = "secret-from-idp"
redirect_uri = "https://stoatchat.example.com/auth/oidc/callback"
backchannel_logout_uri = "https://stoatchat.example.com/auth/oidc/backchannel_logout"
scopes = ["openid", "profile", "email"]

# Optional: manual endpoint configuration (overrides discovery)
# authorization_endpoint = "..."
# token_endpoint = "..."
# jwks_uri = "..."
```

---

## Dependencies

Add to `crates/delta/Cargo.toml`:

```toml
[dependencies]
openidconnect = "4.0"      # OIDC client library (latest: 4.0.1)
jsonwebtoken = "10"        # JWT validation for logout tokens (latest: 10.x)
serde_urlencoded = "0.7"   # Parse backchannel logout form data
```

---

## Summary

The **hybrid OIDC layer** approach provides:
- Functional OIDC authentication without modifying authifier
- Single logout via backchannel logout (IdP → Stoatchat)
- Coexistence with email/password authentication
- ~1-2 weeks implementation time
- Reversible with minimal impact

This is the pragmatic path forward for adding OIDC to Stoatchat while preserving the existing authentication infrastructure.

---

## Appendix: Detailed Approach Comparison

### 1. Extend authifier (Contributive)

Fork authifier to add OIDC mode alongside email/password authentication.

**Pros**:
- Maintains consistency with Revolt/Stoatchat ecosystem
- Could benefit upstream community
- Preserves existing session model

**Cons**:
- Authifier has no OIDC support today, design is email/password-centric
- Requires deep understanding of authifier internals (models, database trait, event system)
- Risk of divergence if upstream rejects PR or goals differ
- Maintenance burden: forking means owning future merges

**Effort**: Medium-High (2-3 weeks if familiar with Rocket + authifier)

---

### 2. OIDC Delegation Layer (Hybrid) — CHOSEN

Keep authifier unchanged, add an OIDC overlay in delta that creates an authifier account via SSO.

**Principle**:
- New route `/auth/oidc/login` redirects to OIDC provider
- Callback `/auth/oidc/callback`:
  - Validates OIDC token via `openidconnect`
  - Finds or creates corresponding authifier account (email from OIDC claims)
  - Creates standard authifier session
  - Returns session token

**Pros**:
- **No authifier modifications** → zero risk to existing auth
- OIDC users appear as normal accounts in DB
- Works with existing infrastructure (onboarding, sessions, optional MFA)
- Can coexist with classic email/password auth

**Cons**:
- OIDC users have a "shadow" authifier account (with unknown random password)
- No native single sign-out (OIDC logout doesn't auto-close Stoatchat session) — solvable with backchannel logout
- Partial duplication: both OIDC provider and authifier store users

**Effort**: Medium (1-2 weeks)

---

### 3. Complete authifier Replacement (From Scratch)

Remove authifier, implement custom OIDC-first auth system in delta.

**Pros**:
- Design tailored for OIDC, no email/password legacy
- No external dependency to maintain
- Full control over auth logic

**Cons**:
- **Major change**: impacts api, events, pushd, crond (everything using authifier)
- Loses authifier features (lockout, email normalization, integrated TOTP MFA)
- Existing users must migrate or require compat mode (added complexity)
- Risk of security regressions if implementation isn't solid

**Effort**: High (3-4 weeks + bug risk)

---

### 4. Migrate to actix-web (Nuclear Option)

Replace Rocket with actix-web to use `actix_web_openidconnect`.

**Pros**:
- Mature, maintained OIDC middleware
- actix-web is more performant and popular than Rocket

**Cons**:
- **Complete rewrite** of delta, bonfire, services (all are Rocket today)
- Breaks Revolt upstream ecosystem
- Disproportionate effort just to add OIDC

**Effort**: Prohibitive (multiple months)

---

## References

- [Authifier GitHub](https://github.com/authifier/authifier)
- [openidconnect Rust crate](https://crates.io/crates/openidconnect)
- [OIDC Back-Channel Logout specification (Auth0)](https://auth0.com/docs/authenticate/login/logout/back-channel-logout)
- [ZITADEL backchannel logout guide](https://zitadel.com/docs/guides/integrate/back-channel-logout)
- [Logout token structure (LDAPWiki)](https://ldapwiki.com/wiki/Wiki.jsp?page=Logout+Token)
- [rocket_oidc (abandoned)](https://github.com/csssuf/rocket_oidc)
- [actix_web_openidconnect](https://lib.rs/crates/actix_web_openidconnect)
